ADJUST { .text-center }
-------

&nbsp;

### 通用接口规格

注意：**本处介绍 TMY 规则引擎中执行体的数项通用接口，对所有插件及 LLM 问答机都适用。**

为描述方便，我们将定义执行体的配置字典记为 task_cfg，task_cfg 中的各项配置，都支持两种表达方式，一是直接给出常量值，二是提供表达式，表达式可包含字串引用与变量引用。

&nbsp;

#### A. 组织输入

执行体由 `task_cfg.input` 指定输入数据。它固定取 str 类型，缺省值为空字串，表示自动从上一个执行体的运行结果（即 `STEP_RESULT` 变量）取值，或由 `task_cfg.INPUT` 指示按特定方式构造一个临时变量（`INPUT` 变量）来取值。

采用 `task_cfg.input` 与 `task_cfg.INPUT` 构造执行体的输入，主要有以下几种使用模式。

其一，`task_cfg.input` 取空值（即缺省值），`task_cfg.INPUT` 也取空值（也是缺省值），表示自动从 `STEP_RESULT` 取值。

> 执行体的输入可以是任意类型，但多数执行体只接受 str 数据，当接行体只接受 str 时，若遇 bytes 输入，系统会自动将它按 utf8 转换成 str 类型。

> 触发词 rule 定义中凡是用 `"*"` 匹配到用户键入的余下字串，被视为前置输入，在启动执行体运行之前都自动存入 `STEP_RESULT` 变量，前置输入还同时存到 `QUESTION` 变量中。

其二，`task_cfg.input` 取空值（即缺省值），`task_cfg.INPUT` 指示一个变量，表示自动从该变量读值用作输入。

> 比如 `task_cfg.INPUT` 取值类似于 `STEP_RESULT[0]` 或 `'words[list][0]' if {words[list_size]!r} else 'EMPTY_STR'` 均可，前者直接给出变量位置，后者是表达式，动态算出变量位置。

其三，`task_cfg.input` 取 `SHIFT POPUP LOOPBACK LOOPFRONT` 其中之一，如果它是表达式，动态计算出这 4 者之一也可以，这时，`task_cfg.INPUT` 被假定要指向一个 list 类型的变量（如果变量不是 list，系统将报错），表示要从这个 list 中取一个成员用作输入。

> 如果 `task_cfg.input` 取 `"SHIFT"`，表示从 list 弹出首个成员；如果取 `"POPUP"` 表示从 list 弹出最末一个成员；如果取 `"LOOPBACK"` 表示从 list 取第一个成员，而且将此成员从原位挪到最末位置；如果取 `"LOOPFRONT"` 表示从 list 取最末一个成员，而且将此成员从原位挪到第一个位置。

> 通过这个方式如果对某个全局变量做操作，变量取值变化会自动同步到数据库中保存，某对局部变量操作，则只在本次触发的执行过程有效。 

其四，`task_cfg.input` 取值是上述 4 项（针对 list 操作 4 个值）之外的任何值，将直接用作输入。

> 这时，我们可以使用 `task_cfg.INPUT`，也可以不使用它。如果使用，所指示的变量值会登记为 `INPUT` 临时变量，然后 `task_cfg.input` 表达式可以引用这个临时变量。

&nbsp;

#### B. 组织输出

规则引擎中的所有执行体都会输出处理结果，对于 LLM 问答机，输出就是 AI 返回的结果字串，对于其它插件，也必然对应输入，设有输出，其处理过程可以简单为：为输入数据作某种处理，然后输出处理结果。

缺省情况下，各执行体自动将处理结果存入 `STEP_RESULT` 变量，或者，如果执行过程遇到错误，就将出错信息（是 str 类型）存入 `STEP_ERROR` 变量。

除了自动保存 `STEP_RESULT`，我们还可以用 `task_cfg.save` 指示将处理结果额外存入指定的变量位置。比如 `save` 若指示 `"some_var[attr1][8][attr2]"`，系统除了存 `STEP_RESULT` 外，还再在指定变量位置保存处理结果。

`task_cfg.save` 缺省取值是空串，表示不额外保存。

我们还可以用 `task_cfg.save` 指示往 `STEP_ERROR` 保存某 str 值，含义是，执行过程出现错误，系统将自动终止本次问答（后面的执行体不再运行）。

&nbsp;

#### C. 跨执行体的变量控制

任务调度器（task scheduler）除了上述以 `task_cfg` 通用接口（输入与输出）让各执行体实现交互，还通过如下局部变量区分上下文环境或改变执行体行为。

- `MAGIC`，记录当前触发词，在执行体运行前就自动设置，宜只读使用，可用作辅助条件判断。

- `QUESTION`，记录当前用户输入的问题（即，用 `"*"` 匹配到的输入字串），宜只读使用。

- `STEP_URI`，记录当前执行体的 ID，宜只读使用。

- `STEP_ERROR`，记录当前运行是否出错，取空字串表示未出错。

- `STEP_RESULT`，记录当前插件的运行结果，可以是任意数据类型。

- `PRE_ANSWER`，缺省为空串，在本次问答的返回值头部插入一个字串，这在多个执行体被调用，须同时返回多个结果时比较有用。典型做法是，利用 ADJUST 插件的转存功能（比如借助 `task_cfg.input` 引用旧 `PRE_ANSWER` 值，与新增描述串接，再存回 `PRE_ANSWER` 变量）实现信息叠加。

- `POST_ANSWER`，缺省为空串，与 `PRE_ANSWER` 类似，但用于在问答结果的尾部添加字串。

- `STEP_SUMMARY`，以 `["<ask>","answer"]` 格式总结历史问答，缺省情况下不必使用本变量，但如果对它赋值，就意味着紧接着的下次问答中，指定的 ask 与 answer 将用来替代当前所有聊天记录。本变量可用来节约聊天成本，因为上传给 LLM 的聊天上下文缩减了，按 token 消耗计算的费用会降低，尤其是当次提问或回答占用过多字数时很有用。

&nbsp;

### ADJUST 插件功能

ADJUST 插件为 str 与 list 数据提供几项常用处理，包括 slice、strip、upper、lower 等。同时，借助 ADJUST 插件的变量转存能力，它还经常用来帮其它插件准备运行环境。 

&nbsp;

### 配置项

ADJUST 插件提供 `task_cfg.actions` 与 `task_cfg.no_output` 配置项。

本插件主要提供三方面功能，一是变量转存，二是对 str 类型的输入值做处理，三是对 list 类型的输入值作 adjust 处理。后两者具体如何处理由 `task_cfg.actions` 指定，如果 `actions` 是空字串，表示对输入不作转换处理（如 slice、strip、upper、lower 等），它的缺省值就是空字串，即 `""`。

本插件用于变量转存时，`actions` 需取空字串，另外，通常还指定 `task_cfg.no_output` 为 true，以免 `STEP_RESULT` 变量因自动赋值而被覆盖。`no_output` 缺省值是 false，运行结果会自动写入 `STEP_RESULT`。

现在介绍变量转存功能，转存由 `task_cfg.save` 指示目标变量路径，举例如下：

``` json
{
  "room_name": "测试",
  "globals": {"words":{},"EMPTY_STR":""},
  "magic_rules": {"*":["*"]},
  "prompts": {
    "*": [
      { "uri":"ADJUST",
        "actions":"split",
        "save":"words[list]" },
      { "uri":"ADJUST",
        "INPUT":"words[list]",
        "actions":"size",
        "no_output":true,
        "save":"words[list_size]" },
      { "uri":"ADJUST",
        "INPUT":"'words[list][0]' if {words[list_size]!r} else 'EMPTY_STR'",
        "input":"value={INPUT}",
        "no_output":true,
        "save":"words[curr]" }
    ]
  }
}
```

这个例子定义了 3 个执行体，均引用 ADJUST 插件。第 1 个执行体对用户输入的文本进行单词分割，因为 `INPUT` 缺省，系统自动从 `STEP_RESULT` 或 `QUESTION` 取值，然后对输入文本进行 split 操作，结果得到 list 类型的数据，自动存入 `STEP_RESULT` 变量，也同时由 `save` 指示存入全局变量 `words['list']`。然后第 2 个执行体取 `words['list']` 作为输入，然后调用 size 统计，得到该列表的长度值，是 int 类型，存入全局变量 `words['list_size']`，这一步因为指定 `no_output` 为 true，结果值不会自动保存到 `STEP_RESULT`，免得上一个执行体的运行结果被覆盖。然后第 3 个执行体依据 `words['list_size']` 不同取值，动态决定从列表中取首个单词，还是取空字串，计算结果按 `value={INPUT}` 组织，然后写入变量 `words['curr']`。

接下来，我们详细介绍 actions 对 str 及 list 数据的 ajust 操作规格。

对于 str 类型的输入值，actions 支持如下操作：

- `split` 分割单词，返回 list 类型的单词列表
- `splitlines` 分割行，返回 list 类型的字串列表，各行均用 strip 删首尾空白符，若遇到空白行则忽略它（不添加到 list 列表）
- `strip` 删除字串首尾空白字符，返回调整后的 str 类型值
- `upper` 将字串转成大写
- `lower` 将字串转成小写
- `slice` 取字串片断
- `replace` 将字串中所有出现 sub_str 子字串的地方都替换成 new_str 新字串
- `size` 统计字串长度，返回 int 值

这些指令中，`slice` 要求在其后带 2 个参数，指定 `start_pos` 与 `end_pos` 以便实现 `value[start_pos:end_pos]` 片断截取，`replace` 也要求在其后带 2 个参数，指定的 `sub_str` 与 `new_str` 都是变量名，上面其它指令均不带参数。

对于 list 类型的输入值，actions 支持如下操作：

- `get` 从列表中取子元素，返回值类型由子元素决定
- `pop` 从列表中弹出指定位置的子元素，返回值类型由子元素决定
- `join` 用指定的间隔符字串连接各个子元素，各子元素将当成 str 类型处理
- `insert` 在列表的指定位置插入某变量值，变量名可以含多级指示，如 `some_var[attr1][8][attr2]`
- `slice` 取列表片断，返回新的 list 数据
- `random` 对 list 所有子元素进行随机数据，返回调整后 list
- `sort` 对 list 子元素进行从小到大排序，返回调整后 list
- `reverse` 将 list 中所有元素的位置反转重排，返回调整后 list
- `loopback` 弹出 list 首个元素，并将它添加到 list 末尾，返回调整后的 list
- `loopfront` 弹出 list 最后一个元素，并将它添加到 list 头部，返回调整后的 list
- `size` 统计 list 长度，返回 int 值

这些指令中，`slice` 要求在其后带 2 个参数，分别指定 `start_pos` 起始与 `end_pos` 结束位置；`insert` 也要求带 2 个参数，分别指定 `pos` 插入位置与 `variable_name` 变量名；`join` 要求带一个 `splitor_var` 参数，用于指示间隔符字串所在的变量名；`get` 与 `pop` 各要求带 1 个 `pos` 参数，用于指示子元素位置，其它指令均不带参数。

以上列出的 actions 各项操作还可以串接使用，具体操作针对 list 还是 str，由被操作数据的类型动态决定。比如，输入数据是 `"one two three four"`，actions 为 `"split sort get 0"` 的计算结果是 `"four"`，第一项操作 split 针对 str 数据进行，后面 sort 与 get 操作则针对前一步计算结果的 list 数据进行。
