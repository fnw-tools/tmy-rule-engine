ADJUST { .text-center }
-------

&nbsp;

### 本插件功能

ADJUST 插件为 str 与 list 数据提供几项常用处理，包括 slice、strip、upper、lower 等。同时，借助 ADJUST 插件的变量转存能力，它还经常用来帮其它插件准备运行环境。 

&nbsp;

### 通用接口规格

**本处介绍 TMY 规则引擎插件的通用接口，对所有插件（包括 LLM 问答机）都适用。**

为描述方便，我们将定义执行体的配置字典记为 `task_cfg`。

- `task_cfg.INPUT` 固定为 str 类型，指示插件输入的临时变量 `INPUT` 如何被安装  
  `task_cfg.INPUT` 缺省取空值（即 `""`），表示自动判断，即，系统先尝试取 `STEP_RESULT` 变量，如果其值为空，就自动改用 `QUESTION` 变量，所得值将赋给临时变量 `INPUT`。  
  `task_cfg.INPUT` 取其它值表示从指定变量（或其子级成员）取值。比如 `STEP_RESULT[0]`，表示取 STEP_RESULT 列表的首个成员，再如，`'words[list][0]' if {words[list_size]!r} else 'EMPTY_STR'` 表达式，系统动态计算后决定从 `words[list][0]` 取值，还是从 `EMPTY_STR` 变量取值。最后所得值将赋给临时变量 `INPUT`。

- `task_cfg.input` 固定为 str 类型，缺省值为空字串，表示直接获得 `task_cfg.INPUT` 的计算值。`input` 若是非空字串，常用于描述插件的输入，正常情况应引用上述 `INPUT` 临时变量（注：不引用也是可以的），如果 `input` 是表达式（内含字串引用或变量引用），系统先计算表达式，得到一个 str 类型的计算值，然后视该 str 为下面哪种取值，再进一步处理。如果 `input` 不是表达式，是字串常量，也视该常量为如下哪种情况分别处理。  
  1）如果值为空值（即 `""`），表示取 `INPUT` 变量自身，这在 ADJUST 插件用于转存变量时比较有用，因为转存前后不改变 `INPUT` 临时变量。  
  2）如果值为 `"SHIFT"`，表示 `INPUT` 变量若是 list 类型，就从该 list 取第一个元素，且从该 list 移走此元素。如果 `INPUT` 变量不是 list 类型就报错。  
  3）如果值为 `"POPUP"`，表示 `INPUT` 变量若是 list 类型，就从该 list 取最后一个元素，且从该 list 移走此元素。如果 `INPUT` 变量不是 list 类型就报错。  
  4）如果值为 `"LOOPBACK"`，表示 `INPUT` 变量若是 list 类型，就从该 list 取第一个元素，而且将此元素从 list 中原位置挪到最未位置。如果 `INPUT` 变量不是 list 类型就报错。  
  5）如果值为 `"LOOPFRONT"`，表示 `INPUT` 变量若是 list 类型，就从该 list 取最后一个元素，而且将此元素从 list 中原位置移到首个位置。如果 `INPUT` 变量不是 list 类型就报错。  
  6）其它值，用作插件的输入

- `task_cfg.save` 指示本执行体的输出结果，是否额外存到指定变量  
  `save` 缺省取空值（即 `""`），表示不额外保存。  
  `save` 取其它值表示存入指定路径的变量，比如：`"some_var[attr1][8][attr2]"`。

说明：

1. 日常实践中，从候选列表选取一项很常用，所以我们借助 `task_cfg.INPUT` 引用某变量，然后经 `task_cfg.input` 指示额外支持 `SHIFT, POPUP, LOOPBACK, LOOPFRONT` 等操作，方便了编程。
2. 在 `task_cfg.INPUT` 采用表达式描述 “不同条件下引用不同变量” 也很常用。这个机制为编程提供了灵活性，比如 `task_cfg.INPUT` 取值 `"'urls[0]' if {urls!r} else 'EMPTY_STR'"`，让 urls 是空列表或非空列表时，都能安全的取其下首成员。
3. 如果 `task_cfg.input` 非空，其计算值也不是 `SHIFT, POPUP, LOOPBACK, LOOPFRONT` 等操作 list 的动作，这时，`task_cfg.input` 计算值必是新创建的值，对它进行 str 或 list 操作（如 ADJUST 插件会针对输入值执行若干转换工作）不影响现有全局变量或局部变量取值，如果想让修改后变量被保存，应在 `task_cfg.save` 指定待存入的全局变量位置。
4. 每件插件（包括 LLM 问答机）启用后，系统都依据 `task_cfg.INPUT` 定义自动生成 `INPUT` 临时变量，`task_cfg` 下其它配置项均可引用 `INPUT` 变量。而且，如果 `task.input` 非空时，`INPUT` 变量将遵循 str 格式优先的方式，即，如果它是 bytes 类型，会按 utf8 格式自动 decode 成 str 类型。
5. 执行体的运行结果会自动存入 `STEP_RESULT` 变量，所以正常情况不必将它用 `save` 存入另一个变量。
6. 用 `save` 指示要保存的目标变量可以是全局变量，也可以是局部变量，在 room 的 `globals` 已经预定义的是全局变量，否则，自动视作局部变量。保存局部变量，则只在当次执行中生效。

请注意，所有执行体 task_cfg 中的各项配置，都支持两种定义方式，一是直接给出常量值，二是提供表达式，表达式内可自由包含字串引用与变量引用的句式。

&nbsp;

任务调度器（task scheduler）除了上述以 `task_cfg` 通用接口与各插件交互，还通过如下局部变量影响插件输入或调整其输出。

- `MAGIC`，记录当前触发词，调用插件前自动设置，可用作条件判断辅助插件运行，宜只读使用。

- `QUESTION`，指示当前用户输入的提问，调用插件前自动设置，宜只读使用。

- `STEP_ERROR`，指示当前运行是否出错，取空字串表示未出错。

- `STEP_RESULT`，记录当前插件的运行结果，可以是任意数据类型。

- `PRE_ANSWER`，在当次问答的返回值头部插入一个字串，多插件调用须同时返回多结果时比较有用。典型做法是，利用 ADJUST 插件的转存功能（借助 `input` 引用旧 `PRE_ANSWER` 值，与新增描述串接，再存回 `PRE_ANSWER` 变量）实现信息叠加。

- `POST_ANSWER`，与 `PRE_ANSWER` 类似，但用于在问答结果的尾部添加字串。

- `STEP_SUMMARY`，以 `["<ask>","answer"]` 格式总结历史问答，缺省情况下不必使用本变量，但如果对它赋值，就意味着紧接着的下次问答中，指定的 ask 与 answer 将用来替代当前所有聊天记录。本变量可用来节约聊天成本，因为上传给 LLM 的聊天上下文缩减了，按 token 消耗计算的费用会降低，尤其是当次提问或回答占用过多字数时很有用。

&nbsp;

### 配置项

ADJUST 插件提供 `task_cfg.actions` 与 `task_cfg.no_output` 配置项。

本插件主要提供三方面功能，一是变量转存，二是对 str 类型的输入值做处理，三是对 list 类型的输入值作 adjust 处理。后两者具体如何处理由 `task_cfg.actions` 指定，如果 `actions` 是空字串，表示对输入不作转换处理（如 slice、strip、upper、lower 等），它的缺省值就是空字串，即 `""`。

本插件用于变量转存时，`actions` 需取空字串，另外，通常还指定 `task_cfg.no_output` 为 true，以免 `STEP_RESULT` 变量因自动赋值而被覆盖。`no_output` 缺省值是 false，运行结果会自动写入 `STEP_RESULT`。

现在介绍变量转存功能，转存由 `task_cfg.save` 指示目标变量路径，举例如下：

``` json
{
  "room_name": "测试",
  "globals": {"words":{},"EMPTY_STR":""},
  "magic_rules": {"*":["*"]},
  "prompts": {
    "*": [
      { "uri":"ADJUST",
        "actions":"split",
        "save":"words[list]" },
      { "uri":"ADJUST",
        "INPUT":"words[list]",
        "actions":"size",
        "no_output":true,
        "save":"words[list_size]" },
      { "uri":"ADJUST",
        "INPUT":"'words[list][0]' if {words[list_size]!r} else 'EMPTY_STR'",
        "input":"value={INPUT}",
        "no_output":true,
        "save":"words[curr]" }
    ]
  }
}
```

这个例子定义了 3 个执行体，均引用 ADJUST 插件。第 1 个执行体对用户输入的文本进行单词分割，因为 `INPUT` 缺省，系统自动从 `STEP_RESULT` 或 `QUESTION` 取值，然后对输入文本进行 split 操作，结果得到 list 类型的数据，自动存入 `STEP_RESULT` 变量，也同时由 `save` 指示存入全局变量 `words['list']`。然后第 2 个执行体取 `words['list']` 作为输入，然后调用 size 统计，得到该列表的长度值，是 int 类型，存入全局变量 `words['list_size']`，这一步因为指定 `no_output` 为 true，结果值不会自动保存到 `STEP_RESULT`，免得上一个执行体的运行结果被覆盖。然后第 3 个执行体依据 `words['list_size']` 不同取值，动态决定从列表中取首个单词，还是取空字串，计算结果按 `value={INPUT}` 组织，然后写入变量 `words['curr']`。

接下来，我们详细介绍 actions 对 str 及 list 数据的 ajust 操作规格。

对于 str 类型的输入值，actions 支持如下操作：

- `split` 分割单词，返回 list 类型的单词列表
- `splitlines` 分割行，返回 list 类型的字串列表，各行均用 strip 删首尾空白符，若遇到空白行则忽略它（不添加到 list 列表）
- `strip` 删除字串首尾空白字符，返回调整后的 str 类型值
- `upper` 将字串转成大写
- `lower` 将字串转成小写
- `slice` 取字串片断
- `replace` 将字串中所有出现 sub_str 子字串的地方都替换成 new_str 新字串
- `size` 统计字串长度，返回 int 值

这些指令中，`slice` 要求在其后带 2 个参数，指定 `start_pos` 与 `end_pos` 以便实现 `value[start_pos:end_pos]` 片断截取，`replace` 也要求在其后带 2 个参数，指定的 `sub_str` 与 `new_str` 都是变量名，上面其它指令均不带参数。

对于 list 类型的输入值，actions 支持如下操作：

- `get` 从列表中取子元素，返回值类型由子元素决定
- `pop` 从列表中弹出指定位置的子元素，返回值类型由子元素决定
- `join` 用指定的间隔符字串连接各个子元素，各子元素将当成 str 类型处理
- `insert` 在列表的指定位置插入某变量值，变量名可以含多级指示，如 `some_var[attr1][8][attr2]`
- `slice` 取列表片断，返回新的 list 数据
- `random` 对 list 所有子元素进行随机数据，返回调整后 list
- `sort` 对 list 子元素进行从小到大排序，返回调整后 list
- `reverse` 将 list 中所有元素的位置反转重排，返回调整后 list
- `loopback` 弹出 list 首个元素，并将它添加到 list 末尾，返回调整后 list
- `loopfront` 弹出 list 最后一个元素，并将它添加到 list 头部，返回调整后 list
- `size` 统计 list 长度，返回 int 值

这些指令中，`slice` 要求在其后带 2 个参数，分别指定 `start_pos` 起始与 `end_pos` 结束位置；`insert` 也要求带 2 个参数，分别指定 `pos` 插入位置与 `variable_name` 变量名；`join` 要求带一个 `splitor_var` 参数，用于指示间隔符字串所在的变量名；`get` 与 `pop` 各要求带 1 个 `pos` 参数，用于指示子元素位置，其它指令均不带参数。

以上列出的 actions 各项操作还可以串接使用，具体操作针对 list 还是 str，由被操作数据的类型动态决定。比如，输入数据是 `"one two three four"`，actions 为 `"split sort get 0"` 的计算结果是 `"four"`，第一项操作 split 针对 str 数据进行，后面 sort 与 get 操作则针对前一步计算结果的 list 数据进行。
